1. When performing file I/O, if Scanners and PrintWriters are used
   for file input and output, respectively, an IOException will be 
   thrown if the file isn't successfully opened for input or output. This
   is important because the inability to read from or write to
   a data file could lead to a fatal error when executing the program.
   
   
   import java.io.FileReader;
   import java.io.IOException;
   import java.util.Scanner;
   
   
   Scanner inFile = new Scanner(new FileReader(filename));  
   //where 'filename' is a String variable containing the filename
   //If this fails, an IOException will be thrown.
   
   - Write code to read the data from the file.
   
   All the Scanner methods, .nextInt(), .next(), .nextLine(), .nextDouble(),
   etc. can then be used to read the data from the file. Be sure to close
   the file stream when you no longer need access to the file.
   
   inFile.close();

2. A lambda function borrows its name from mathematics (lambda calculus). A
   lambda expression is an anonymous function. It allows us to use a function 
   without a variable binding although in Java we can bound a lambda expression 
   to an interface variable.

   Java is not inherently a functional programming language but we can pass one 
   function as an argument to another in JDK 1.8 or later. In versions of Java 
   prior to JDK 1.8, one had to use a rather convoluted approach by defining an 
   interface, defining a class that implements the interface, passing an object of 
   that class as an argument to a method, and using that object to invoke the method 
   defined in the interface to achieve this effect.  Now, we can pass a built-in 
   lambda functional as an argument to a method or define our own interface and then 
   use a lambda method.
   
   Functional interfaces provide target types for lambda expressions and methods. 
   Each functional interface has a single abstract method, called functional method 
   for that functional interface, to which the lambda expression's parameter and 
   return types are matched or adapted. The commonly used ones are:
   
   The java.util.function Package
   Function is not the only functional interface provided with Java SE 8. Here are
   some of the standard interfaces that are frequently used by software developers:

   -Predicate: A property of the object passed as argument
   -Consumer: An action to be performed with the object passed as argument
   -Function: Transform a T to a U
   -Supplier: Provide an instance of a T (such as a factory)
   -UnaryOperator: A unary operator from T -> T
   -BinaryOperator: A binary operator from (T,T) -> T
   
   For a full list of interfaces provided in the function package, see: 
   https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html   
   
   Another commonly used interface Comparator<E> defined in the standard Java library
   is used for lambdas. 
   
   -Comparator<? super T>:  (T,T) -> int 
   
   eg: This may be used to substitute the comparator above. It compares two strings by
       their lengths.
   
   Comparator<String> strCmp = (s1,s2) ->
   {
      if (s1.length() > s2.length())
	     return 1;
      if (s1.length() < s2.length())
	     return -1;
	  return 0;   
   }
   
   Note: In Java 8 one does not have to explicitly override the compare method. The method
   in {} overrides the abstract compare method defined in the Comparator interface.
   The strCmp variable is a reference to an object of an anonymous class that implements the
   generic Comparator interface. The lambda function on the right of the assignment statement
   overrides the abstract compare method in that interface. strCmp.compare can be used to 
   invoke the method. The signature of the compare method is (T,T) -> int.   
   
   
   We will use Comparator lambda parameters when implementing some of the abstract
   data types in this course. We will also use the Function functional. So make sure that you 
   fully understand both of them.
   
   In addition, many of these interfaces also have primitive versions. Use these
   built-in interfaces defined in the functional package. If they don't meet your
   needs, you can then define your own interface. Here is an example that uses
   the Function interface.
   
   import java.util.Scanner;
   import java.io.PrintStream;
   import java.util.function.Function;   
   
   public class LambdaFunctionDemo
   {   
       /**
        * Applies the function f to the specified string
        * @param f a lambda function
        * @param line a string
        */
       public static void printLine(Function f, String line)
       {
           f.apply(line);
       }
       public static void main(String[] args)
       {
           Scanner cin = new Scanner(System.in);
           System.out.print("Enter a line of text -> ");
           String line = cin.nextLine();
           //Explicit declaration of the lambda function.
           Function<String,PrintStream> printUpperCase = x -> System.out.printf("%S",x);
           printLine(printUpperCase,line);
           System.out.println();
           //Or, implicitly (anonymously) defining the lambda function.
           printLine(x -> System.out.printf("%S",x),line);
           System.out.println();
           //Explicit declaration of the lambda function.
           Function<String,PrintStream> printLowerCase = x -> System.out.printf("%s",x.toLowerCase());
           printLine(printLowerCase,line);
           System.out.println();
           //Or, implicitly (anonymously) defining the lambda function if its type can be inferred. 
           //printLine(x -> System.out.printf("%s",x.toLowerCase()),line);	   
           System.out.println();
       }
   }
   
   Note: Any lambda of the form String -> T can be used for the f functional that is
   the first argument of printLine.
   
   If you need to define your own interface that takes three arguments and gives
   an output, you could define the generic interface below:
   
   public class UserDefinedFunctionalInterfaceDemo
   {   
       public interface TripleArity<W,X,Y,Z>
       {
          W apply(X x, Y y, Z z);
       }   
       public static void g(TripleArity<Integer,Integer,Integer,Integer> func, int a, int b, int c)
       {
           System.out.printf("f(%d,%d,%d) = %d%n",a,b,c,func.apply(a,b,c));
       }
       public static void main(String[] args)
       {
           g((x,y,z) -> x+y+z,4,5,6);
           g((x,y,z)->x*x+y*y+z*z, 4,5,6);
       }
   }
		 
   One more thing: one could store a lambda function to a variable:
   
   Function<Double,Double> square = num -> num * num;
   or, longer version but the same:
   Function<Double,Double> square = num -> {return  num * num;};
   
   Note: The lambda function overrides the public R apply(T t); abstract method 
   defined in the standard Java Function interface. 'square' is a reference
   to an implicitly instantiated object of an anonymous class that implements
   the Functional interface.
	     
   square.apply is a function with the prototype double square.apply(double).
   
3. Java 1.8 API provides a generic Deque<E> interface. Among standard Java classes 
   that implement this interface is the generic ArrayDeque<E> class. This class is 
   a doubly-ended queue. A deque, doubly-ended queue, unlike a regular queue, allows 
   for dequeuing and enqueuing from either end. We can use a deque whenever we need 
   a queue. 
   
   Code-reuse is an important goal of software development and maintenance. If there 
   is a robust implementation of a software component, we may be better off using 
   it rather than building the component from scratch. You may already be familiar 
   with the standard Java library container ArrayList, a generic extensible array. 
   
   In this course, we may need to use a queue in the implementation of some algorithms
   and data structures. You could use an array list or a deque or other containers 
   already implemented in Java 1.8. For the generic deque interface API documentation, see:
   https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html 
   and for the generic ArrayDeque and LinkedList API documentations, see
   https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html and
   https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html  
   The ArrayDeque class, like the ArrayList class, uses dynamic resizing while the 
   LinkedList class is a doubly-linked list.
   
   Observe that the LinkedList<E> class implements the Deque<E> interface.
   See the demo program below that illustrates how to use the Deque<E> interface
   with the LinkedList<E> class.
   
   import java.util.*;
   public class DequeDemo
   {
      public static void main (String[] args) throws NoSuchElementException
      {
         Deque<Character> letters = new LinkedList();
         letters.addLast('A');
         System.out.printf("%c inserted into the queue.%n",letters.getLast());
         letters.addLast('E');
         System.out.printf("%c inserted into the queue.%n",letters.getLast());
         letters.addLast('I');
         System.out.printf("%c inserted into the queue.%n",letters.getLast());
         letters.addLast('O');
         System.out.printf("%c inserted into the queue.%n",letters.getLast());
         letters.addLast('U');
         System.out.printf("%c inserted into the queue.%n",letters.getLast());
         // The queue letters now contains UOIEA where the left-most item is the bottom 
         // and the right-most item is the top of the queue.
         System.out.printf("The size of the queue is %d.%n",letters.size());
         while(!letters.isEmpty())   //This loop pops the letters from top-to-bottom
         {
            System.out.printf("%c is removed from the queue.%n",letters.getFirst());
            letters.removeFirst();
            //or, alternatively, replacing both lines with one line:
            //System.out.printf("%c is removed from the queue.%n",letters.removeFirst());
         }
         System.out.printf("The size of the queue is %d.%n",letters.size());
      }
   }   